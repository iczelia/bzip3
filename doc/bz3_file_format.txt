
BZip3 file format
*****************

   In the diagram below, a box like this:

    +---+
    |   | <-- the vertical bars might be missing
    +---+

   represents one byte; a box like this:

    +==============+
    |              |
    +==============+

   represents a variable number of bytes.


   A bz3 file consists header and a series of chunks (compressed data blocks).
   The file may contain an unlimited amount of chunks.

   It has the following structure:

## The header

    +--+--+--+--+--+---+---+---+----+
    |  signature   | max block size |
    +--+--+--+--+--+---+---+---+----+

   All multibyte values are stored with least significant byte first (little endian order).

'signature (the "magic" bytes)'
     A five byte string, identifying the bz3 format, with the value "bz3v1"
     (0x62, 0x7a, 0x33, 0x76, 0x31)

'max block size (4 bytes)'
    32-bit number signifying the maximum block size in bytes.
    As such, no block after decompression in the stream can exceed it. The maximum block size must be between 65KiB and 511MiB.

## The chunk/s

    +--+--+--+---+--+--+--+-----+============+-+-+-+-+
    | comp. size | decomp. size | comp. data | crc32 |
    +--+--+--+---+--+--+--+-----+============+-+-+-+-+

'comp. size (4 bytes)'
    32-bit integer signifying the _compressed_ size of the block
'decomp. size (4 bytes)'
    32-bit integer signifying the _decompressed_ size
'comp. data'
    sequence of bzip3-compressed data
'crc32 (4 bytes)'
    crc32 checking is left up to libbz3.


All multibyte values are stored with least significant byte first.
The following functions are used for serialising all 32-bit numbers to the archive:

```c
static s32 read_neutral_s32(u8 * data) {
    return ((u32)data[0]) | (((u32)data[1]) << 8) | (((u32)data[2]) << 16) | (((u32)data[3]) << 24);
}

static void write_neutral_s32(u8 * data, s32 value) {
    data[0] = value & 0xFF;
    data[1] = (value >> 8) & 0xFF;
    data[2] = (value >> 16) & 0xFF;
    data[3] = (value >> 24) & 0xFF;
}
```

If the chunk is smaller than 64 bytes, then compression is not attempted. Instead, the content is prepended with the 32-bit CRC32 checksum and a 0xFFFFFFFF literal.

Otherwise, the chunk starts with the 32-bit CRC32 checksum value, the Burrows-Wheeler transform permutation index and the compression _model_ - a 8-bit value specifying the compression preset used. As such:

- 2-s bit set in the _model_ - LZP was used and the 32-bit size is prepended to the block.
- 4-s bit set in the _model_ - RLE was used and the 32-bit size is prepended to the block.
- No other bit can be set in the _model_.

The size of libbz3's block header can be calculated using the formula `popcnt(model) * 4 + 1`.

